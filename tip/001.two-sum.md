# 两数相加的解法举例和心路历程

首先这是leetcode的第一题，看起来肯定不是很难的。一开始的定式思维肯定是采用穷举法，这种方法直接且有效。如果不考虑运行时间的前提下，这个方法肯定是最好的。并且也是最节省空间的。

大家知道做算法的时候的制衡点就是时间和空间。如果需要时间的最快化必然要采用附加的空间来实现。本题就是典型的时间空间制衡的问题。

下面我们就来排演一下解题的心路历程

### 穷举法
穷举法顾名思义就是写两个for循环。外层从数组0位置开始，内层从数组1位置开始寻找出第一个符合条件的2个数字。

这个方法想必大家都会写，这也是最节省空间的一个写法。因为占用的内存就是你输入的数组的size。

然而leetcode的要求是从时间复杂度上能尽量最小。所以这个算法肯定是不适合的，或者说归根结底这不算是一个算法。下面是我的示例代码： 

 ```java
    public int[] twoSum(int[] nums, int target) {
        int[] result = new int[2];
        for(int i =0;i<nums.length; i++){
          for (int j =1; j<nums.length; j++){
            if(i !=j && nums[i]+nums[j] == target){
              result[0] = i;
              result[1]= j;
              return result;
            }
          }
        }
      return null;
    }
 ```
 答案写是写完了。但是结果触目惊心：执行用时: 130 ms, 在Two Sum的Java提交中击败了3.65% 的用户。这显然不是一个令人满意的答案。
 
当然你也会说，我们可以做一个变种，从后面往前面取。其实这个效率不会提高太多。所以这里就暂且不表了。

在我们不能满意的情况下，我在想有没有第二个办法能够提高效率的。这时候我的想法就从不添加任何附加的空间改变改变成可以牺牲一部分的空间来换取时间的优越性。

映入我的脑海的是HashMap这样的一个数据结构。HashMap是一个基于哈希表的Map实现。可为基本操作（get 和 put）提供稳定的性能。我们不过多的表述HashMap的原理。面试题里面比比皆是。而下面我们直接来表一下使用HashMap的算法。

###HashMap暂存遍历法
```java
public int[] twoSum(int[] nums, int target) {
Map<Integer,Integer> result = new HashMap<Integer,Integer>();
for(int i=0; i<nums.length; i++){
    result.put(nums[i],i);
}  

for(int i=0;i<nums.length; i++){
    int res = target - nums[i];
    if(result.containsKey(res) && result.get(res) != i){
    return new int []{i,result.get(res)};
    }
}
return null;
}
```
这个写法直接应用了HashMap的特性。出来的结果是：执行用时: 6 ms, 在Two Sum的Java提交中击败了93.69% 的用户。看起来还是蛮不错的。基本上已经达到我们的要求了。占用的空间也就是原来的double。应该是可以接受的。

以上。
